"""

This program converts text into emoji's to encrypt the string. It also can decrypt the emoji's if
they were generated by this program.

You can input via the command line OR use a file to save/load.

"""
import numpy as np
import argparse
import emoji
import re

DEBUG = False
DEBUG_ENCRYPTED = False

DEFAULT_ENCRYPTION_DICT = {
    "a" : ":chicken:", "A" : ":eye:", "b" : ":adult:", "B" : ":no_mouth:",
    "c" : ":cold_face:", "C" : ":8ball:", "d" : ":pretzel:", "D" : ":radioactive_sign:",
    "e" : ":bagel:", "E" : ":sauropod:", "f" : ":shower:", "F" : ":ski:",
    "g" : ":teddy_bear:", "G" : ":tiger:", "h" : ":ant:", "H" : ":unicorn_face:",
    "i" : ":video_game:", "I" : ":banana:", "j" : ":waning_crescent_moon:", "J" : ":cowboy_hat_face:",
    "k" : ":1st_place_medal:", "K" : ":vampire:", "l" : ":mega:", "L" : ":male_sign:",
    "m" : ":beetle:", "M" : ":moyai:", "n" : ":panda_face:", "N" : ":panda:",
    "o" : ":penguin:", "O" : ":strawberry:", "p" : ":heart:", "P" : ":lion_face:",
    "q" : ":fire:", "Q" : ":moon:", "r" : ":stuck_out_tongue_winking_eye:", "R" : ":elf:",
    "s" : ":yo_yo:", "S" : ":nerd_face:", "t" : ":mouse:", "T" : ":crab:",
    "u" : ":crown:", "U" : ":deer:", "v" : ":dna:", "V" : ":eagle:",
    "w" : ":egg:", "W" : ":first_quarter_moon_with_face:", "x" : ":fish:", "X" : ":japanese_goblin:",
    "y" : ":kangaroo:", "Y" : ":banjo:", "z" : ":kissing_cat:", "Z" : ":magnet:",
    "0" : ":dog:", "1" : ":t-rex:", "2" : ":hedgehog:", "3" : ":cow:", "4" : ":fireworks:",
    "5" : ":raccoon:", "6" : ":trophy:", "7" : ":waffle:", "8" : ":juggling_person:", "9" : ":love_you_gesture:",
    " " : " "
}



def main():
    """
    Uses files to read and write encryption/decryption.
    If the files are not specified then the user is asked for input.
    """
    number_of_passes = 1 # number of passes to encrypt or decrypt is always 1 by default

    parser = argparse.ArgumentParser(
                        prog='Message Encoder/Decoder',
                        description='Encodes and Decodes basic messages',
                        epilog='Basic encryption for fun!')

    parser.add_argument('-n',
                        help='number of encryption/decryptions',
                        dest='number_of_passes',
                        type=str,
                        nargs=1,
                        required=False)

    parser.add_argument('-fie',
                        help='File to read in the encrypted message from to decrypt. Must be used with -fod argument.',
                        dest='encrypted_read_file_location',
                        type=str,
                        nargs=1,
                        required=False)

    parser.add_argument('-foe',
                        help='File to save the encrypted message to.',
                        dest='encrypted_write_file_location',
                        type=str,
                        nargs=1,
                        required=False)

    parser.add_argument('-fid',
                        help='File to read in the decrypted message from to encrypt. Must be used with -foe argument.',
                        dest='decrypted_read_file_location',
                        type=str,
                        nargs=1,
                        required=False)

    parser.add_argument('-fod',
                        help='File to save the decrypted message to.',
                        dest='decrypted_write_file_location',
                        type=str,
                        nargs=1,
                        required=False)

    args = parser.parse_args()

    if DEBUG:
        print(f"-fie {args.encrypted_read_file_location}")
        print(f"-foe {args.encrypted_write_file_location}")
        print(f"-fid {args.decrypted_read_file_location}")
        print(f"-fod {args.decrypted_write_file_location}")
        print(f"-n {args.decrypted_write_file_location}")

    encode_or_decode = "E"
    # no arguments passed in. Ask the user to enter a message and if to Encrypt or decrypt it.
    if args.encrypted_read_file_location is None and args.decrypted_read_file_location is None:
        secret_message = input("Insert in an encrypted or text message[Test Message]: ") or "Test Message"
        if args.encrypted_write_file_location is not None:
            encode_or_decode = "E"
        elif args.decrypted_write_file_location is not None:
            encode_or_decode = "D"
        else:
            encode_or_decode = input("Are we encodeing (E) or decodeing (D) the message. [E]: ")  or "E"

        number_of_passes = int(input("Number of Passes [1]: ")  or 1)
        check_inputs(secret_message, encode_or_decode)


        # I would like to multipass the encrypt/decrypt but the copy/paste command is not working correctly
        if encode_or_decode == "E":
            encrypted_array = encrypt(secret_message)
            encrypted_message = [str(x) for x in encrypted_array]
            encrypted_message = "".join(encrypted_message)
            number_of_passes -= 1 # we already did a pass
            for _ in range(number_of_passes):
                encrypted_array = encrypt_the_encrypted(encrypted_message)
                encrypted_message = [str(x) for x in encrypted_array]
                encrypted_message = "".join(encrypted_message)
            if args.encrypted_write_file_location is not None:
                print(f"Writing to File: {args.encrypted_write_file_location[0]}")
                save_message(args.encrypted_write_file_location[0], encrypted_message)
            else:
                print(encrypted_message)

        elif encode_or_decode == "D":
            for _ in range(number_of_passes):
                decrypted_array = decrypt(secret_message)
                decrypted_message = [str(x) for x in decrypted_array]
                secret_message = emoji.emojize("".join(decrypted_message), language='alias')

            if args.decrypted_write_file_location is not None:
                print(f"Writing to File: {args.decrypted_write_file_location[0]}")
                save_message(args.decrypted_write_file_location[0], secret_message)
            else:
                print(secret_message)

    else:

        if args.number_of_passes:
            number_of_passes = int(args.number_of_passes[0])

        if args.decrypted_read_file_location and (args.encrypted_write_file_location is None):
            parser.error("-fid requires -foe.")

        elif args.decrypted_read_file_location and args.encrypted_write_file_location:
            secret_message = load_message_from_file(args.decrypted_read_file_location[0])
            encrypted_array = encrypt(secret_message)
            encrypted_message = [str(x) for x in encrypted_array]
            encrypted_message = "".join(encrypted_message)
            if number_of_passes > 1:
                number_of_passes -= 1 # we already did a pass
                for _ in range(number_of_passes):
                    encrypted_array = encrypt_the_encrypted(encrypted_message)
                    encrypted_message = [str(x) for x in encrypted_array]
                    encrypted_message = "".join(encrypted_message)
            print(f"Writing to File: {args.encrypted_write_file_location[0]}")
            save_message(args.encrypted_writef_ile_location[0], encrypted_message)

        if args.encrypted_read_file_location and (args.decrypted_write_file_location is None):
            parser.error("-fie requires -fod.")

        elif args.encrypted_read_file_location and args.decrypted_write_file_location:
            secret_message = load_message_from_file(args.encrypted_read_file_location[0])
            for _ in range(number_of_passes):
                decrypted_array = decrypt(secret_message)
                decrypted_message = [str(x) for x in decrypted_array]
                secret_message = emoji.emojize("".join(decrypted_message), language='alias')
            print(f"Writing to File: {args.decrypted_write_file_location[0]}")
            save_message(args.decrypted_write_file_location[0], secret_message)


def check_inputs(secret_message, encode_or_decode):
    """
    Validates that the input through manual entry is valid

    :param str secret_message: The message to encrypt must contain alpha/numeric characters
    :param str encode_or_decode: do we E encode the message or D decode the message
    :return: True
    :rtype: boolean
    :raises ValueError: If the secret_message does not have alpha/numeric characters or E or D was not chosen to encode or decode the message.

    """
    secret_message = emoji.demojize(secret_message, language='alias')

    if encode_or_decode != "E" and encode_or_decode != "D":
        raise ValueError("Bad information selected. Please choose E for encode or D for decode.")

    if len(secret_message) < 0 or re.search(r"[^\W_]+", secret_message) is None:
        raise ValueError("Enter in at least one letter or number to encode.")

    return True

def encrypt(secret_message):
    """
    Replaces each alpha/numeric character with the emoji chart to scramble the message.

    :param secret_message: The message to encrypt
    :return: encrypted message as str[]
    :rtype: emoji[]

    """
    encrypted_message = []
    for word in secret_message:
       encrypted_message = list(np.append(encrypted_message,encrypt_word(word)))

    return encrypted_message

def encrypt_the_encrypted(encrypted_text):
    encrypted_message = []
    for word in encrypted_text:
        word = emoji.demojize(word, language='alias')
        encrypted_message = list(np.append(encrypted_message,encrypt_word(word)))

    return encrypted_message

def encrypt_word(word):
    """

    Replaces each word with an emoji

    :param word: The word to encrypt
    :return: encrypted message as str[]
    :rtype: emoji[]

    """
    encrypted_message = []
    for character in word:
        if character.isalnum():
            encrypted_message.append(emoji.emojize(DEFAULT_ENCRYPTION_DICT[character], language='alias'))
        else:
            encrypted_message.append(character)
    return encrypted_message

def decrypt(secret_message):
    """

    Replaces each alpha/numeric emoji with a character to un-scramble the message.

    :param secret_message: The message to decrypt in emoji format
    :return: decrypted message as str[]
    :rtype: str[]

    """
    decrypted_message = []

    for word in secret_message:
        word = emoji.demojize(word, language='alias')
        if DEBUG_ENCRYPTED:
            print(word)
        if len(word) > 1:
            decrypted_message.append(list(DEFAULT_ENCRYPTION_DICT.keys())[list(DEFAULT_ENCRYPTION_DICT.values()).index(word)])
        else:
            decrypted_message.append(word)

    return decrypted_message

def save_message(file_name, secret_message):
    """

    Saves the file to the file system with the message sent.

    :param file_name: The name of the file to save the data to.
    :param secret_message: The message to save

    """
    with open(file_name, 'w') as f:
        f.write(secret_message)

def load_message_from_file(file_name):
    """

    Loads an entire file based on file name and return the data.

    :param file_name: The file to load
    :return: The full file loaded as a string
    :rtype: str
    :raises NameError: If the file is not found.

    """
    all_of_it = ""
    with open(file_name) as file:
        all_of_it = file.read()

    return all_of_it


if __name__ == "__main__":
    main()
